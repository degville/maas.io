{% extends "docs/base_docs.html" %}

{% block page_class %}docs{% endblock %}

{% block content %}
<h1 id="rpc-howto">RPC HOWTO</h1>
<p>MAAS contains an RPC mechanism such that every process in the region is connected to every process in the cluster (strictly, every pserv process). It's based on <a href="http://amp-protocol.net/">AMP</a>, specifically <a href="http://twistedmatrix.com/documents/current/core/howto/amp.html">Twisted's implementation</a>.</p>
<h2 id="where-do-i-start">Where do I start?</h2>
<p>Start in the :pyprovisioningserver.rpc package. The first two files to look at are <code>cluster.py</code> and <code>region.py</code>. This contain the declarations of what commands are available on clusters and regions respectively.</p>
<p>A new command could be declared like so:</p>
<pre><code>from twisted.protocols import amp

class EatCheez(amp.Command):
    arguments = [
        (b&quot;name&quot;, amp.Unicode()),
        (b&quot;origin&quot;, amp.Unicode()),
    ]
    response = [
        (b&quot;rating&quot;, amp.Integer()),
    ]</code></pre>
<p>It's also possible to map exceptions across the wire using an <code>errors</code> attribute; see the docs or code for more information.</p>
<p>Note that byte-strings are used for parameter names. Twisted gets quite fussy about this, so remember to do it.</p>
<h2 id="implementing-commands">Implementing commands</h2>
<p>To implement a new command on the cluster, see the class :pyprovisioningserver.rpc.clusterserver.Cluster. A method decorated with <code>@cluster.EatCheez.responder</code> is the implementation of the <code>EatCheez</code> command. There's no trick to this, they're just plain old functions. However:</p>
<ul>
<li>They only receive named parameters, so the arguments <em>must</em> match the names used in the command's <code>arguments</code> declaration.</li>
<li>They <em>must</em> return a dict that matches the command's <code>response</code> declaration.</li>
<li>If the <code>response</code> declaration is empty they <em>must</em> still return an empty dict.</li>
</ul>
<p>To implement a new command on the region, see the class :pymaasserver.rpc.regionserver.Region. It works the same.</p>
<h2 id="making-remote-calls-from-the-region-to-the-cluster">Making remote calls from the region to the cluster</h2>
<p>There's a convenient API in :pymaasserver.rpc:</p>
<ul>
<li>:py~maasserver.rpc.getClientFor returns a client for calling remote functions against the cluster identified by a specified UUID.</li>
<li>:py~maasserver.rpc.getAllClients will return clients for all connections to cluster processes.</li>
</ul>
<p>The clients returned are designed to be used in either the reactor thread <em>or</em> in another thread; when called from the latter, a :pycrochet.EventualResult will be returned.</p>
<h2 id="making-remote-calls-from-the-cluster-to-the-region">Making remote calls from the cluster to the region</h2>
<p>You need to get a handle to the <code>rpc</code> service that will have been started by <code>twistd</code>.</p>
<p>Probably the best way to do this is implement the behaviour you want as a new service, start it up via same mechanism as the <code>rpc</code> service (see :pyprovisioningserver.plugin, and pass over a reference.</p>
<p>Then call :py~provisioningserver.rpc.getClient, and you will get a client for calling into a region process. You're given a random client.</p>
<h2 id="making-multiple-calls-at-the-same-time-from-outside-the-reactor">Making multiple calls at the same time from outside the reactor</h2>
<p>A utility function -- :py~maasserver.utils.async.gather -- helps here. An example:</p>
<pre><code>from functools import partial

from maasserver.rpc import getAllClients
from maasserver.utils import async
from twisted.python.failure import Failure

# Wrap those calls you want to make into no-argument callables, but
# don&#39;t call them yet.
calls = [
    partial(client, EatCheez)
    for client in getAllClients()
]

# Use gather() to issue all the calls simultaneously and process the
# results as they come in. Note that responses can be failures too.
for response in async.gather(calls, timeout=10):
    if isinstance(response, Failure):
        pass  # Do something sensible with this.
    else:
        celebrate_a_cheesy_victory(response)</code></pre>
<p>Responses can be processed as soon as they come in. Any responses not received within <code>timeout</code> seconds will be discarded.</p>
<h2 id="miscellaneous-advice">Miscellaneous advice</h2>
<ul>
<li>Don't hang onto client objects for long periods of time. It's okay for a sequence of operations, but don't keep one around as a global, for example; get a new one each time.</li>
<li>It's a distributed system, and errors are going to be normal, so be prepared.</li>
</ul>
<h2 id="api">API</h2>
<h3 id="controlling-the-event-loop-in-region-controllers">Controlling the event-loop in region controllers</h3>
<h3 id="rpc-declarations-for-region-controllers">RPC declarations for region controllers</h3>
<h3 id="rpc-implementation-for-region-controllers">RPC implementation for region controllers</h3>
<h3 id="rpc-declarations-for-cluster-controllers">RPC declarations for cluster controllers</h3>
<h3 id="rpc-implementation-for-cluster-controllers">RPC implementation for cluster controllers</h3>
<h3 id="helpers">Helpers</h3>
{% endblock %}